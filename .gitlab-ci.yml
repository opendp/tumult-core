# GitLab CI can create duplicate pipelines in certain cases when one event that
# triggers a pipeline (e.g. a push) causes another such event (e.g. the
# resulting update to an MR). This block prevents that in common cases.
workflow:
  rules:
    # If pushing to a branch that has an open MR associated with it, don't
    # launch the on-push pipeline.
    - if: '$CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS && $CI_PIPELINE_SOURCE == "push"'
      when: never
    - when: always

# Define the potential stages that can be run in a GitLab CI pipeline job
stages:
  - setup
  - lint
  - test
  - docs
  - package
  - test-release
  - release
  - handler

variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  POETRY_VIRTUALENVS_IN_PROJECT: "true"
  PACKAGE_NAME: "core"

.base:
  image: registry.gitlab.com/tumult-labs/ops/ci/ci-full:latest
  before_script:
    - java -version
    - python --version
    - poetry --version
    - poetry config --list
    - poetry install -v --remove-untracked
    # `poetry shell` is inherently interactive, so the virtualenv must be activated manually
    - . .venv/bin/activate
  cache:
    - key:
        files: ["poetry.lock"]
      paths:
        - .venv
        - .cache/pip
      policy: pull
  tags: [aws-small]
  interruptible: true

# "Fake" job to prevent dev pipelines from being interrupted on new commits.
# See gitlab-org/gitlab#34221
prevent_dev_interrupt:
  stage: setup
  script:
    - echo "No-op job to prevent dev pipelines from being interrupted"
  variables:
    GIT_STRATEGY: none
  timeout: 1m
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'

# Install dependencies
setup:
  extends: .base
  stage: setup
  script:
    - echo "setup"
  cache:
    # As long as poetry.lock remains the same, the virtual environment can
    # be reused -- even across branches.
    - key:
        files: ["poetry.lock"]
      paths: [".venv"]
      policy: pull-push
  timeout: 10m
  tags: [aws-small]
  interruptible: true

lint:
  extends: .base
  stage: lint
  needs:
    - job: setup
      artifacts: false
  script:
    - make lint
  timeout: 12m
  rules:
    - if: '$CI_COMMIT_TAG'
      when: never
    - when: always

test:
  extends: .base
  stage: test
  needs:
    - job: setup
      artifacts: false
  script:
    - make test-fast
  coverage: '/^TOTAL.+?(\d+\%)$/'
  artifacts:
    reports:
      cobertura: coverage.xml
      junit: junit.xml
    expire_in: 1 week
  timeout: 1h
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule" || $CI_COMMIT_TAG'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TITLE !~ /^[Dd]raft:/'
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - when: manual
      allow_failure: true
  tags: [aws-large]

test_nightly:
  extends: test
  script:
    - make test-slow
  timeout: 23h
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      allow_failure: true
    - if: '$CI_COMMIT_TAG'
      when: never
    - when: manual
      allow_failure: true

trigger_analytics_with_core_commit_hash_nightly:
  stage: test
  needs:
    - job: test_nightly
      artifacts: false
  trigger:
    project: tumult-labs/analytics
    branch: dev
  variables:
    CORE_COMMIT_HASH: "$CI_COMMIT_SHA"
  rules:
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'

docs:
  extends: .base
  stage: docs
  needs:
    - job: setup
      artifacts: false
  variables:
    # Require the CI executor to fetch all refs in the repo -- this ensures that
    # sphinx-multiversion can detect all of the versions that might need to be
    # built.
    GIT_DEPTH: 0
    SPHINX_EXTRA_OPTS: "-n -W --keep-going"
    SPHINX_LINKCHECK: "true"
  script:
    - git checkout -B head
    - cd $CI_PROJECT_DIR
    - if [[ "$(sphinx-multiversion doc public --dump-metadata)" == "{}" ]] ; then
      echo "Skipping docs build, no docs versions would be built" ;
      exit 0 ;
      fi
    - |
      echo "Versions to build:"
      sphinx-multiversion doc public --dump-metadata | jq "[.[].name]"
    - |
      # Set up a function for running tests
      function run_sphinx_tests() {
        echo "Version options: $SMV_TEST_VERSION_OPTS"
        if [ "$SPHINX_LINKCHECK" = "true" ]; then
             python -m http.server --directory $CI_PROJECT_DIR & # Start webserver in background
             sleep 1 # Wait for the server to start
             echo "Running linkcheck..."
             BASE_URL_OVERRIDE="http://localhost:8000" sphinx-multiversion doc/ public/ -b linkcheck $SMV_TEST_VERSION_OPTS
             kill $! # Kill the server process
        fi
        echo "Running test build..."
        sphinx-multiversion doc/ public/ $SPHINX_EXTRA_OPTS $SMV_TEST_VERSION_OPTS
        echo "Running doctest..."
        sphinx-multiversion doc/ public/ -b doctest $SMV_TEST_VERSION_OPTS
      }
    - |
      # When building a tag, run the usual tests.
      if [[ "$CI_COMMIT_TAG" ]]; then
        SMV_TEST_VERSION_OPTS="-D smv_branch_whitelist=^\$ -D smv_tag_whitelist=^$CI_COMMIT_TAG\$"
        run_sphinx_tests
      # For branches, create a temporary branch called head at the current commit,
      # and run the usual tests against that. Keep it around for the final build
      # on feature branches, but on the default branch delete it.
      else
        SMV_TEST_VERSION_OPTS="-D smv_branch_whitelist=^head\$ -D smv_tag_whitelist=^\$"
        run_sphinx_tests
      fi
    - rm -rf public/
    - sphinx-multiversion doc/ public/
    # Add a page to automatically redirect the base directory of the site to the
    # latest or most relevant version. sort -V doesn't completely correctly handle
    # semantic versioning, but it works well enough for this purpose.
    - |
      if [ "$CI_COMMIT_TAG" ] ; then
        # Try to choose a non-prerelease version as the default; if there isn't
        # one, then use the latest pre-release.
        DEFAULT_VERSION="$(find public/ -maxdepth 1 -type d | cut -d '/' -f2 | grep -vE '(alpha|beta|rc)' | sort -V | tail -n1)"
        if [ -z "$DEFAULT_VERSION" ]; then
          DEFAULT_VERSION="$(find public/ -maxdepth 1 -type d | cut -d '/' -f2 | sort -V | tail -n1)"
        fi
      elif [ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ] ; then
        DEFAULT_VERSION="$CI_DEFAULT_BRANCH"
      else
        DEFAULT_VERSION="head"
      fi
    - echo "<head><meta http-equiv=\"refresh\" content=\"0; url='./$DEFAULT_VERSION/'\" /></head>" > public/index.html
  artifacts:
    paths:
      - public/
    expire_in: 1 week
    expose_as: 'Tumult Core - documentation'
  timeout: 15m
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" && $CI_MERGE_REQUEST_TITLE !~ /^[Dd]raft:/'
    - if: '$CI_COMMIT_TAG'
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - when: manual
      allow_failure: true

package:
  stage: package
  needs: []
  image: registry.gitlab.com/tumult-labs/ops/ci/ci-full:latest
  script:
    - make package
  artifacts:
    paths:
      - dist/
    expire_in: 1 week
  timeout: 3m
  rules:
    - if: '$CI_COMMIT_TAG'
  interruptible: true

test_release:
  stage: test-release
  needs:
    - job: package
      artifacts: true
  image: registry.gitlab.com/tumult-labs/ops/ci/ci-full:latest
  script:
    - virtualenv .venv
    - . .venv/bin/activate
    - pip install -r test_requirements.txt
    - pip install dist/*.whl
    - pip freeze
    - make test-fast
  coverage: '/^TOTAL.+?(\d+\%)$/'
  artifacts:
    reports:
      cobertura: coverage.xml
      junit: junit.xml
    expire_in: 1 week
  timeout: 1h
  rules:
    - if: '$CI_COMMIT_TAG'
  tags: [aws-large]

publish:
  stage: release
  dependencies: [package]
  image: registry.gitlab.com/tumult-labs/ops/ci/ci-full:latest
  script:
    - cd $CI_PROJECT_DIR/$PACKAGE_DIR
    - export EXPECTED_TAG="$(poetry version -s)"
    - |
      if [ "$EXPECTED_TAG" != "$CI_COMMIT_TAG" ]; then
        echo "Pyproject version $EXPECTED_TAG does not match tag version $CI_COMMIT_TAG"
        exit 1
      fi
    - poetry config repositories.gitlab "https://gitlab.com/api/v4/projects/${CI_PROJECT_ID}/packages/pypi"
    - poetry publish -r gitlab -u gitlab-ci-token -p "${CI_JOB_TOKEN}"
  timeout: 3m
  rules:
    - if: '$CI_COMMIT_TAG'
  interruptible: false

# This job requires the TUMULT_DOCS_CONTAINER_REGISTRY_WRITE_USER and
# TUMULT_DOCS_CONTAINER_REGISTRY_WRITE_TOKEN variables to be set. They should be
# the name and token of a project access token from the tumult/tumult-docs
# project with the read_registry and write_registry permissions.
publish_docs:
  stage: release
  image:
    name: gcr.io/kaniko-project/executor:v1.6.0-debug
    entrypoint: [""]
  before_script:
    - if [ "$CI_COMMIT_TAG" ] ; then
        IMAGE_TAG="release-$(date +%Y%m%d%H%M%S)" ;
      else
        IMAGE_TAG="git-$CI_COMMIT_BRANCH" ;
      fi
  script:
    - |
      cat <<EOF > /kaniko/.docker/config.json
      {
        "auths": {
          "registry.gitlab.com": {
            "username": "$TUMULT_DOCS_CONTAINER_REGISTRY_WRITE_USER",
            "password": "$TUMULT_DOCS_CONTAINER_REGISTRY_WRITE_TOKEN"
          }
        }
      }
      EOF
    - echo "IMAGE_TAG=$IMAGE_TAG" > .env
    - /kaniko/executor --cleanup
        --dockerfile "$CI_PROJECT_DIR/doc/Dockerfile"
        --context "$CI_PROJECT_DIR/$PACKAGE_DIR"
        --destination "registry.gitlab.com/tumult-labs/tumult-docs/$PACKAGE_NAME:$IMAGE_TAG"
        --label "git-version=$CI_COMMIT_REF_NAME"
        --label "git-commit=$CI_COMMIT_SHORT_SHA"
  artifacts:
    reports:
      dotenv: ".env"
  timeout: 3m
  interruptible: false
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
      when: never
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
    - if: '$CI_COMMIT_TAG'

trigger_release:
  stage: release
  image: registry.gitlab.com/tumult-labs/ops/ci/ci-full:latest
  script:
    - make prepare-release
    - git config user.name "gitlab"
    - git config user.email "gitlab@tmlt.io"
    - git checkout -B "release/$VERSION"
    - git add -u
    - git diff --staged --stat
    - git commit -m "[auto] Prepare release $VERSION" --author "$CI_COMMIT_AUTHOR"
    - git tag "$VERSION"
    - |
      git remote add origin-https \
          "https://$RELEASER_TOKEN_USERNAME:$RELEASER_TOKEN@gitlab.com/$CI_PROJECT_PATH.git"
    - git push origin-https "release/$VERSION" --push-option ci.skip
    - git push origin-https "$VERSION"
    - |
      cat > body.json <<EOF
      {
        "source_branch": "release/$VERSION",
        "target_branch": "dev",
        "title": "Merge release $VERSION",
        "assignee_id": $GITLAB_USER_ID,
        "remove_source_branch": true,
        "squash": false,
        "approvals_before_merge": 1
      }
      EOF
    - cat body.json
    - |
      http_status=$(
        curl -XPOST -s -o response.json -w "%{http_code}" \
            "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests" \
            --header "PRIVATE-TOKEN: $RELEASER_TOKEN" \
            -H "Content-Type: application/json" -d "@body.json"
      )
      echo "Response body:"
      cat response.json | jq
      if [[ $http_status -ne 201 ]]; then
        echo "Got unexpected HTTP status $http_status, exiting..."
        exit 1
      fi
  timeout: 30m
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule" && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      when: manual
  tags: [aws-small]
  interruptible: false

release_handler:
  stage: handler
  script:
    - |
      # TODO: Add a link to the docs to this message as well, once we start
      # automatically publishing them to the public site from this pipeline.
      cat > body.json <<EOF
      {
        "blocks": [
          {
            "type": "section",
            "text": {
              "type": "mrkdwn",
              "text": "*Core Release $CI_COMMIT_TAG*\n<https://gitlab.com/tumult-labs/core/-/packages|:package: Package Registry>    <$CI_PIPELINE_URL|:factory: Pipeline>"
            }
          }
        ]
      }
      EOF
    - |
      if [[ -z "$SLACK_RELEASE_WEBHOOK_URL" ]]; then
        echo "SLACK_RELEASE_WEBHOOK_URL unset"
        exit 1
      fi
    - |
      http_status=$(
        curl -XPOST -s -o response.json -w "%{http_code}" \
            "$SLACK_RELEASE_WEBHOOK_URL" \
            -H "Content-Type: application/json" -d "@body.json"
      )
      echo "Response body:"
      cat response.json
      if [[ $http_status -ne 200 ]]; then
        echo "Got unexpected HTTP status $http_status, exiting..."
        exit 1
      fi
  timeout: 2m
  rules:
    - if: '$CI_COMMIT_TAG'
  interruptible: false
